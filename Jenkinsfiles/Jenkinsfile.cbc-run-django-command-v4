pipeline {
  agent {
    kubernetes {
      defaultContainer "bb2-cbc-build"
      yamlFile "Jenkinsfiles/cbc-build_django.yaml"
    }
  }

  environment {
    AWS_DEFAULT_REGION = "us-east-1"
    SSH_KEY = credentials("bb2-ssh-key-${params.APP_ENV}-V4")
  }

  parameters {
    choice(
      name: "APP_ENV",
      choices: ["test", "impl", "prod"],
      description: "The environment to run in."
    )

    string(
      name: "DJANGO_COMMAND",
      defaultValue: "",
      description: "The django management command to run."
    )

    string(
      name: "CANARY_IP",
      defaultValue: "",
      description: "When this is set, run against a canary IP rather than a tagged deployment instance"
    )
  }

  stages {
    stage("Notify Slack") {
      steps {
        script {
          helpers = load "Jenkinsfiles/helpers.groovy"
          helpers.slackNotify "STARTING - ENV:${params.APP_ENV}"
        }
      }
    }

    stage("Assume AWS Role") {
      steps {
        withCredentials([string(credentialsId: params.APP_ENV == 'test' ? 'aws-assume-role-arn' : 'aws-assume-role-arn-prod', variable: 'ROLE_ARN')]) {
          script {
            def sessionName = "jenkins-${env.BUILD_ID}"
            def credsJson = sh(
              script: """#!/bin/bash
              aws sts assume-role \\
                --role-arn "$ROLE_ARN" \\
                --role-session-name "$sessionName" \\
                --output json
              """,
              returnStdout: true
            ).trim()

            def creds = readJSON text: credsJson

            env.AWS_ACCESS_KEY_ID     = creds.Credentials.AccessKeyId
            env.AWS_SECRET_ACCESS_KEY = creds.Credentials.SecretAccessKey
            env.AWS_SESSION_TOKEN     = creds.Credentials.SessionToken
            // --- ADD THESE DEBUG LINES ---
            echo "Assumed Role ARN: ${ROLE_ARN}"
            echo "Assumed Access Key ID (partial): ${env.AWS_ACCESS_KEY_ID.substring(0, 8)}..." // Print first 8 chars
            echo "Assumed Session Token (partial): ${env.AWS_SESSION_TOKEN.substring(0, 8)}..." // Print first 8 chars
            echo "Assumed Role Expiration: ${creds.Credentials.Expiration}" // Print expiration time
            // DO NOT print env.AWS_SECRET_ACCESS_KEY directly as it's highly sensitive
            def callerIdentity = sh(
              script: """#!/bin/bash
              aws sts get-caller-identity --output text
              """,
              returnStatus: true
            )

            if (callerIdentity != 0) {
              error("Failed to verify assumed AWS role. Check credentials or permissions.")
            } else {
              echo "Successfully verified assumed AWS role: ${sh(script: 'aws sts get-caller-identity', returnStdout: true).trim()}"
            }
          }
        }
      }
    }

    stage("Determine Ansible Config") {
      steps {
        script {
          if (params.CANARY_IP != "") {
            echo("Setting ansible config for canary IP")
            ANSIBLE_INVENTORY = "${params.CANARY_IP},"
            ANSIBLE_SUBSET = ""
          } else {
            echo("Setting ansible config for tagged deployment instance")
            ANSIBLE_INVENTORY = "inventory/ec2.py"
            ANSIBLE_SUBSET = "tag_Function_app_AppServer"
          }
        }
      }
    }

    stage("Run Django Command") {
      steps {
        script { // <--- IMPORTANT: Enclose this stage's logic in a 'script' block
            def awsAccessKeyId = env.AWS_ACCESS_KEY_ID
            def awsSecretAccessKey = env.AWS_SECRET_ACCESS_KEY
            def awsSessionToken = env.AWS_SESSION_TOKEN
            def awsDefaultRegion = env.AWS_DEFAULT_REGION
            def currentAppEnv = params.APP_ENV
            def currentDjangoCommand = params.DJANGO_COMMAND
            def sshKey = SSH_KEY

            def ec2IniPath = "inventory/config/${currentAppEnv}.ini"

            // --- Construct the EC2 script test command as a Groovy String ---
            def ec2ScriptTestCommand = """#!/bin/bash
                echo "DEBUG: Current working directory:"
                pwd
                echo "DEBUG: User running the script:"
                id

                echo "DEBUG: Permissions BEFORE chmod:"
                ls -ld inventory/config/
                ls -l inventory/config/test.ini # Check permissions of the specific INI file
                ls -l inventory/ec2.py          # Check permissions of the inventory script itself
                echo "DEBUG: Permissions of parent directory 'inventory/':"
                ls -ld inventory/
                echo "DEBUG: Permissions of workspace root directory:"
                ls -ld /home/jenkins/agent/workspace/Blue\\ Button/Bluebutton-GFM/RUN\\ -\\ Django\\ Command/

                echo "INFO: Applying chmod to inventory/config/ and files..."
                chmod a+r inventory/config/*.ini || { echo "ERROR: Failed to set read permissions on INI files. Exit code: \$?"; exit 1; }
                chmod a+x inventory/config/ || { echo "ERROR: Failed to set execute permissions on config directory. Exit code: \$?"; exit 1; }
                chmod a+x inventory/ec2.py || { echo "ERROR: Failed to set execute permissions on ec2.py. Exit code: \$?"; exit 1; }

                echo "DEBUG: Permissions AFTER chmod:"
                ls -ld inventory/config/
                ls -l inventory/config/test.ini
                ls -l inventory/ec2.py

                echo "===> Environment variables for EC2 inventory script:"
                printenv | grep "AWS_ACCESS_KEY_ID"
                printenv | grep "AWS_SECRET_ACCESS_KEY"
                printenv | grep "AWS_SESSION_TOKEN"
                printenv | grep "AWS_DEFAULT_REGION"

                echo "===> Testing direct boto3 describe_instances call..."
                export AWS_ACCESS_KEY_ID='${awsAccessKeyId}'
                export AWS_SECRET_ACCESS_KEY='${awsSecretAccessKey}'
                export AWS_SESSION_TOKEN='${awsSessionToken}'
                export AWS_DEFAULT_REGION='${awsDefaultRegion}'

                python - <<EOF
import os
import boto3
try:
    print(f"Using region: ${awsDefaultRegion}")
    client = boto3.client('ec2', region_name=os.environ.get('AWS_DEFAULT_REGION'))
    response = client.describe_instances()
    print('boto3 describe_instances SUCCESS!')
except Exception as e:
    print(f'boto3 describe_instances FAILED: {e}')
    import traceback
    traceback.print_exc()
EOF

                echo "===> Direct boto3 test complete."

                # --- CRITICAL SECTION WITH NEW EXPORT STRATEGY ---
                echo "===> Testing EC2 inventory script with assumed role credentials..."
                echo "DEBUG: Exporting EC2_INI_PATH='${ec2IniPath}'"
                export EC2_INI_PATH="${ec2IniPath}" # Groovy interpolates ${ec2IniPath} here

                echo "DEBUG: About to run: python inventory/ec2.py --list"

                # Capture stdout and stderr separately for detailed debugging
                # Now, the $(...) only contains the `python` command, no complex assignment
                EC2_PY_STDOUT_CONTENTS=\$(python inventory/ec2.py --list)
                EC2_PY_STDOUT_STATUS=\$?

                EC2_PY_STDERR_CONTENTS=\$(python inventory/ec2.py --list 1>&2 >/dev/null)
                EC2_PY_STDERR_STATUS=\$?

                echo "DEBUG: EC2_PY_STDOUT (JSON output expected):"
                echo "\${EC2_PY_STDOUT_CONTENTS}"
                echo "DEBUG: EC2_PY_STDERR (errors expected):"
                echo "\${EC2_PY_STDERR_CONTENTS}"
                echo "DEBUG: EC2_PY_STDOUT_STATUS: \${EC2_PY_STDOUT_STATUS}"
                echo "DEBUG: EC2_PY_STDERR_STATUS: \${EC2_PY_STDERR_STATUS}"
                # --- END OF CRITICAL SECTION ---
            """

            // This Groovy variable will capture all the echo'd debug output from the shell script
            def rawEc2PyOutputWithDebug = sh(
                script: ec2ScriptTestCommand,
                returnStdout: true
            ).trim()

            echo "--- EC2 Script Raw Output (from the diagnostic block) ---"
            echo "${rawEc2PyOutputWithDebug}"
            echo "--- End EC2 Script Raw Output (from the diagnostic block) ---"

            echo "===> EC2 inventory script test complete."

            echo "===> Running ansible-playbook with assumed role credentials..."
            def ansiblePlaybookCommand = """#!/bin/bash
                export EC2_INI_PATH="${ec2IniPath}" \\ # Export here for Ansible's run too
                ansible-playbook playbook/run_django_command/main.yml \\
                  --private-key '${sshKey}' \\
                  -i '${ANSIBLE_INVENTORY}' \\
                  -l '${ANSIBLE_SUBSET}' \\
                  -e 'env=${currentAppEnv}' \\
                  -e 'django_command="${currentDjangoCommand}"'
            """
            sh ansiblePlaybookCommand
        } // <--- End of 'script' block
      }
    }
  }

  post {
    success {
      script {
        helpers.slackNotify("SUCCESS - ENV:${params.APP_ENV}", "good")
      }
    }

    failure {
      script {
        helpers.slackNotify("FAILURE - ENV:${params.APP_ENV}", "bad")
      }
    }
  }
}