//*****************************************************************************
// TODO: Remove this
// 12/03/2021
// Blue Button - Full orchestration build & deploy release
// This Jenkinsfile leverages the existing BUILD - App AMI ans DEPLOY - App AMI
// 
// Parameter requirements per job:
// Build:
//  - APP_REPO_BRANCH: (default: master) expecting release - rXX
//  - DEPLOY_REPO_BRANCH: (default:master)
//  - PLATINUM_AMI_ID: (default:most recent (blank)), or specified by AMI ID
//
// Deploy:
//  - APP_MIGRATIONS: options: Pre-deploy, Post-deploy, No Migrations
//  - APP_ENV: options::test, impl, prod
//  - APP_AMI_ID: Gathered in Deployment step
//
//*****************************************************************************

pipeline {
  agent {
    kubernetes {
      defaultContainer "bb2-cbc-build"
      yamlFile "Jenkinsfiles/cbc-build.yaml"
    }
  }

  environment {
    AWS_ACCESS_KEY_ID = credentials("bb2-aws-key-id")
    AWS_SECRET_ACCESS_KEY = credentials("bb2-aws-key-secret")
    AWS_DEFAULT_REGION = "us-east-1"
    VAULT_PASSWORD = credentials("bb2-vault-password")
    SSH_KEY = credentials("bb2-ssh-key-${params.APP_ENV}")
  }

  parameters {

    choice(
      name: "APP_ENV",
      choices: ["test"],
      // TODO: choices: ["test", "impl", "prod"], uncomment once tests are passing in TEST env
      description: "The environment to deploy to."
    )

    choice(
      name: "APP_MIGRATIONS",
      choices: ["", "Pre-deploy", "Post-deploy", "No Migrations"],
      description: "Are there any migrations required for this deploy?"
    )

    string(
      name: "APP_REPO_BRANCH",
      defaultValue: "master",
      description: "The branch of the application repo to build in AMI. Defaults to master."
    )

    string(
      name: "DEPLOY_REPO_BRANCH",
      defaultValue: "master",
      description: "The branch of the deployment repo to build in AMI. Defaults to master."
    )

    string(
      name: "PLATINUM_AMI_ID",
      defaultValue: "",
      description: "The AMI ID of the platinum image. If unset, the latest will be pulled from AWS and used."
    )

    string(
      name: "APP_AMI_ID",
      defaultValue: "",
      description: "The AMI ID for the app image. Leave blank to use AMI from this job's build stage. To use a pre-built AMI instead, put AMI ID here (this will skip the build stage of this job)."
    )
    
  }

  stages {
    // Migration selection check
    stage("Check migration status") {
      steps {
        script {
          if (params.APP_MIGRATIONS == '') {
              currentBuild.result = 'ABORTED'
              error('No app migration selection was made.')
          }
        }
      }
    }
    
    stage("Notify Slack") {
      steps {
        script {
          helpers = load "Jenkinsfiles/helpers.groovy"
          helpers.slackNotify "STARTING - ENV:${params.APP_ENV}"
        }
      }
    }

    // BUILD

    // TODO:
    // ** Think about the scenario where this automated job gets aborted after the build stage - 
    // ** consider an option to use the previously built AMI when running this job again
    // ** The 'when' condition below will skip the build stage if a value is supplied for the APP_AMI_ID
    stage("Build this release") {
      when {
        expression { params.APP_AMI_ID == "" }
      }
      steps {
        // TODO: Change to production job after testing is complete
        build job: 'Z BUILD - App AMI (AMZN 2)', 
          parameters: [
            string(name: 'APP_REPO_BRANCH', value: params.APP_REPO_BRANCH.toLowerCase()), 
            string(name: 'DEPLOY_REPO_BRANCH', value: params.DEPLOY_REPO_BRANCH), 
            string(name: 'PLATINUM_AMI_ID', value: params.PLATINUM_AMI_ID)
          ]
      }
    }

    // Ansible config - Pre-deploy migrations
    stage("Determine Ansible Config") {
      // TODO: Thinking this will need to be run separately for Pre/Post migrations since instances change post deploy
      when {
        expression { params.APP_MIGRATIONS == "Pre-deploy" }
      }
      steps {
        script {
            echo("Setting ansible config for tagged deployment instance")
            ANSIBLE_INVENTORY = "inventory/ec2.py"
            ANSIBLE_SUBSET = "tag_Function_app_AppServer"
          }
        }
      }
    }

    // Pre-deploy showmigrations
    stage("Pre-deploy migration: showmigrations") {
      when {
        expression { params.APP_MIGRATIONS == "Pre-deploy" }
      }
      steps {
        sh """
        EC2_INI_PATH=inventory/config/${APP_ENV}.ini \
        ansible-playbook playbook/run_django_command/main.yml \
          --vault-password-file '${VAULT_PASSWORD}' \
          --private-key '${SSH_KEY}' \
          -i '${ANSIBLE_INVENTORY}' \
          -l '${ANSIBLE_SUBSET}' \
          -e 'env=${APP_ENV}' \
          -e 'django_command="showmigrations"'
        """
      }
    }

    // Pre-deploy migrate
    stage("Pre-deploy migration: Confirm and migrate") {
      when {
        expression { params.APP_MIGRATIONS == "Pre-deploy" }
      }
      input {
        message "Run migrations on ${params.APP_ENV}?"
        ok "Migrate"
      }
      steps {
        echo "Migrate confirmation recieved, proceeding."

        sh """
        EC2_INI_PATH=inventory/config/${APP_ENV}.ini \
        ansible-playbook playbook/run_django_command/main.yml \
          --vault-password-file '${VAULT_PASSWORD}' \
          --private-key '${SSH_KEY}' \
          -i '${ANSIBLE_INVENTORY}' \
          -l '${ANSIBLE_SUBSET}' \
          -e 'env=${APP_ENV}' \
          -e 'django_command="migrate"'
        """
      }
    }


    // DEPLOY
    stage("Determine APP AMI") {
      steps {
        script {
          if (params.APP_AMI_ID != "") {
            echo("Setting APP_SOURCE_AMI_ID from APP_AMI_ID: ${params.APP_AMI_ID}")
            APP_SOURCE_AMI_ID = params.APP_AMI_ID
          } else {
            echo("Setting APP_SOURCE_AMI_ID from AMI just built for ${params.APP_REPO_BRANCH.toLowerCase()}")
            APP_SOURCE_AMI_ID = sh(returnStdout: true, script: "aws ec2 describe-images \
              --filters 'Name=name,Values=bb2-amzn2-${params.APP_REPO_BRANCH.toLowerCase()}-*' \
              --query 'sort_by(Images, &CreationDate)[-1].ImageId' \
              --output text").trim()
        }
      }
    }

    stage("Deploy this release - Be sure to approve/abort Terraform plan on DEPLOY - App AMI job") {
      steps {
        // TODO: Change to production job after testing is complete
        build job: 'Z DEPLOY - App AMI', 
          parameters: [
            string(name: 'APP_MIGRATIONS', value: params.APP_MIGRATIONS), 
            string(name: 'APP_ENV', value: params.APP_ENV), 
            string(name: 'APP_AMI_ID', value: params.APP_SOURCE_AMI_ID)
          ]
      }
    }

    // Ansible config - Pre-deploy migrations
    stage("Determine Ansible Config") {
      // TODO: Thinking this will need to be run separately for Pre/Post migrations since instances change post deploy
      when {
        expression { params.APP_MIGRATIONS == "Post-deploy" }
      }
      steps {
        script {
            echo("Setting ansible config for tagged deployment instance")
            ANSIBLE_INVENTORY = "inventory/ec2.py"
            ANSIBLE_SUBSET = "tag_Function_app_AppServer"
          }
        }
      }
    }

    // Post-deploy showmigrations
    stage("Post-deploy migration: showmigrations") {
      when {
        expression { params.APP_MIGRATIONS == "Post-deploy" }
      }
      steps {
        sh """
        EC2_INI_PATH=inventory/config/${APP_ENV}.ini \
        ansible-playbook playbook/run_django_command/main.yml \
          --vault-password-file '${VAULT_PASSWORD}' \
          --private-key '${SSH_KEY}' \
          -i '${ANSIBLE_INVENTORY}' \
          -l '${ANSIBLE_SUBSET}' \
          -e 'env=${APP_ENV}' \
          -e 'django_command="showmigrations"'
        """
      }
    }

    // Post-deploy migrate
    stage("Post-deploy migration: Confirm and migrate") {
      when {
        expression { params.APP_MIGRATIONS == "Post-deploy" }
      }
      // TODO:
      // Should we, or should we not allow this choice? I think this should be forced since it is
      // going to be required once a deployment goes into production. Or - is it best to review
      // the showmigrations first and do a rollback in the event of an issue?
      input {
        message "Run migrations on ${params.APP_ENV}?"
        ok "Migrate"
      }
      steps {
        echo "Migrate confirmation recieved, proceeding."

        sh """
        EC2_INI_PATH=inventory/config/${APP_ENV}.ini \
        ansible-playbook playbook/run_django_command/main.yml \
          --vault-password-file '${VAULT_PASSWORD}' \
          --private-key '${SSH_KEY}' \
          -i '${ANSIBLE_INVENTORY}' \
          -l '${ANSIBLE_SUBSET}' \
          -e 'env=${APP_ENV}' \
          -e 'django_command="migrate"'
        """
      }
    }

  }

  post {
    success {
      script {
        helpers.slackNotify("SUCCESS - ENV:${params.APP_ENV}", "good")
      }
    }

    failure {
      script {
        helpers.slackNotify("FAILURE - ENV:${params.APP_ENV}", "bad")
      }
    }
  }

}