pipeline {
  agent {
    kubernetes {
      defaultContainer "bb2-cbc-build"
      yamlFile "Jenkinsfiles/cbc-build.yaml"
    }
  }

  environment {
    AWS_DEFAULT_REGION = "us-east-1"
    EC2_KEY = credentials("ec2-user-priv-key")
    EC2_PUB_KEY = credentials("ec2-user-pub-key")
    TARGET_ACCOUNT_ID = credentials("aws-target-account-id")
    ENCRYPT_KMS_ARN = credentials("aws-kms-arn")
  }

  parameters {
    string(name: "APP_REPO_BRANCH", defaultValue: "master", description: "The branch of the application repo to build in AMI.")
    string(name: "DEPLOY_REPO_BRANCH", defaultValue: "master", description: "The branch of the deployment repo to build in AMI.")
    string(name: "PLATINUM_AMI_ID", defaultValue: "", description: "Optional: override the platinum AMI ID.")
    credentials(name: "ec2-user", defaultValue: "ec2-user", description: "SSH user key for provisioning", required: true)
  }

  stages {
    stage("Assume AWS Role") {
      steps {
        withCredentials([string(credentialsId: 'aws-assume-role-arn', variable: 'ROLE_ARN')]) {
          script {
            def sessionName = "jenkins-${env.BUILD_ID}"
            def credsJson = sh(
              script: """#!/bin/bash
              set -euxo pipefail
              aws sts assume-role \
                --role-arn "$ROLE_ARN" \
                --role-session-name "$sessionName" \
                --output json
              """,
              returnStdout: true
            ).trim()
            echo "Assume Role Output: ${credsJson}"

            def creds = readJSON text: credsJson

            env.AWS_ACCESS_KEY_ID     = creds.Credentials.AccessKeyId
            env.AWS_SECRET_ACCESS_KEY = creds.Credentials.SecretAccessKey
            env.AWS_SESSION_TOKEN     = creds.Credentials.SessionToken
          }
        }
      }
    }

    stage("Notify Slack") {
      steps {
        script {
          helpers = load "Jenkinsfiles/helpers.groovy"
          helpers.slackNotify "STARTING"
        }
      }
    }

    stage("Determine Source AMI") {
      steps {
        script {
          if (params.PLATINUM_AMI_ID?.trim()) {
            echo("Using provided PLATINUM_AMI_ID: ${params.PLATINUM_AMI_ID}")
            env.PLATINUM_AMI_ID = params.PLATINUM_AMI_ID
          } else {
            echo("Fetching latest bb2-amzn2023-platinum AMI from AWS")
            env.PLATINUM_AMI_ID = sh(script: """#!/bin/bash
              set -euxo pipefail
              aws ec2 describe-images \
                --filters 'Name=name,Values=bb2-amzn2023-platinum-*' \
                --query 'sort_by(Images, &CreationDate)[-1].ImageId' \
                --output text
            """, returnStdout: true).trim()
            echo "Fetched AMI ID: ${env.PLATINUM_AMI_ID}"
          }
        }
      }
    }

    stage("Fetch Private Subnet ID") {
      steps {
        script {
          sh '''#!/bin/bash
            set -euxo pipefail
            aws ec2 describe-subnets \
              --filters "Name=tag:Name,Values=*private*" "Name=availabilityZone,Values=us-east-1*" \
              --query "Subnets[0].SubnetId" \
              --output text
          '''
          def subnetId = sh(script: '''#!/bin/bash
            aws ec2 describe-subnets \
              --filters "Name=tag:Name,Values=*private*" "Name=availabilityZone,Values=us-east-1*" \
              --query "Subnets[0].SubnetId" \
              --output text
          ''', returnStdout: true).trim()
          echo "Private Subnet ID: ${subnetId}"

          if (subnetId == "None" || !subnetId) {
            error "No private subnet found!"
          } else {
            env.PRIVATE_SUBNET_ID = subnetId
          }
        }
      }
    }

    stage("Build App AMI") {
      steps {
        script {
          sh(script: """#!/bin/bash
            set -euxo pipefail
            # Install session-manager-plugin if not present
            if ! command -v session-manager-plugin &> /dev/null; then
              echo "Installing session-manager-plugin..."
              curl -L "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" -o "session-manager-plugin.deb"
              dpkg -i session-manager-plugin.deb
              rm -f session-manager-plugin.deb
              echo "✅ session-manager-plugin installed"
            else
              echo "session-manager-plugin already installed"
            fi
            # Run packer build and log output
            packer build -color=false \
              -var 'source_ami=${env.PLATINUM_AMI_ID}' \
              -var 'release_version=${params.APP_REPO_BRANCH}' \
              -var 'git_branch=${params.APP_REPO_BRANCH}' \
              -var 'deployment_branch=${params.DEPLOY_REPO_BRANCH}' \
              -var 'ec2-user=${env.EC2_KEY}' \
              -var 'ec2-user-pub-key=${env.EC2_PUB_KEY}' \
              -var 'subnet_id=${env.PRIVATE_SUBNET_ID}' \
              packer/build_app_ami_amzn2.json | tee packer-output.log
          """)

          def builtAmiId = sh(script: "grep 'AMI:' packer-output.log | awk '{print \$2}'", returnStdout: true).trim()
          env.BUILT_AMI_ID = builtAmiId
          echo "✅ AMI for Test Environment: ${env.BUILT_AMI_ID}"
        }
      }
    }

    stage("Copy & Share Encrypted AMI") {
      steps {
        script {
          def amiName = sh(script: """
            set -euxo pipefail
            aws ec2 describe-images \
              --image-ids ${env.BUILT_AMI_ID} \
              --region ${env.AWS_DEFAULT_REGION} \
              --query "Images[0].Name" \
              --output text
          """, returnStdout: true).trim()
          echo "Original AMI name: ${amiName}"

          def copyOutput = sh(script: """
            set -euxo pipefail
            aws ec2 copy-image \
              --source-image-id ${env.BUILT_AMI_ID} \
              --source-region ${env.AWS_DEFAULT_REGION} \
              --region ${env.AWS_DEFAULT_REGION} \
              --name "${amiName}" \
              --description "Copied AMI with encryption" \
              --encrypted \
              --kms-key-id ${env.ENCRYPT_KMS_ARN} \
              --output json | tee ami-copy.json
          """, returnStdout: true).trim()

          def copiedAmi = readJSON text: copyOutput
          def copiedAmiId = copiedAmi.ImageId
          echo "Copied AMI ID: ${copiedAmiId}"

          sh """
            aws ec2 wait image-available --image-ids ${copiedAmiId} --region ${env.AWS_DEFAULT_REGION}
          """

          sh """
            set -euxo pipefail
            aws ec2 modify-image-attribute \
              --image-id ${copiedAmiId} \
              --launch-permission 'Add=[{UserId=${env.TARGET_ACCOUNT_ID}}]' \
              --region ${env.AWS_DEFAULT_REGION}
          """

          def snapshotIdsRaw = sh(script: """
            aws ec2 describe-images \
              --image-ids ${copiedAmiId} \
              --region ${env.AWS_DEFAULT_REGION} \
              --query "Images[0].BlockDeviceMappings[].Ebs.SnapshotId" \
              --output text
          """, returnStdout: true).trim()
          def snapshotIds = snapshotIdsRaw.split()
          echo "Snapshot IDs: ${snapshotIds.join(', ')}"

          snapshotIds.each { snapshotId ->
            sh """
              set -euxo pipefail
              aws ec2 modify-snapshot-attribute \
                --snapshot-id ${snapshotId} \
                --attribute createVolumePermission \
                --operation-type add \
                --user-ids ${env.TARGET_ACCOUNT_ID} \
                --region ${env.AWS_DEFAULT_REGION}
            """
          }

          echo "✅ AMI ${copiedAmiId} and snapshots shared with ${env.TARGET_ACCOUNT_ID}"
        }
      }
    }
  }

  post {
    success {
      script {
        helpers.slackNotify("SUCCESS", "good")
      }
    }
    failure {
      script {
        helpers.slackNotify("FAILURE", "bad")
      }
    }
  }
}
